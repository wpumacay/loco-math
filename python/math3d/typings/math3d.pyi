from typing import Union, Tuple, List, overload
from numpy import ndarray

################################################################################
#                           Type hints for Vector2                             #
################################################################################

class Vector2:
    def __init__(
        self, *args: Union[float, ndarray], **kwargs: Union[float, ndarray]
    ): ...
    @property
    def x(self) -> float: ...
    @x.setter
    def x(self, value: float) -> None: ...
    @property
    def y(self) -> float: ...
    @y.setter
    def y(self, value: float) -> None: ...
    def __add__(self, rhs: Vector2) -> Vector2: ...
    def __sub__(self, rhs: Vector2) -> Vector2: ...
    def __mul__(self, scale: float) -> Vector2: ...
    def __rmul__(self, scale: float) -> Vector2: ...
    def __eq__(self, other: Vector2) -> bool: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: float) -> None: ...
    def __neq__(self, other: Vector2) -> bool: ...
    def __neg__(self) -> Vector2: ...
    def dot(self, rhs: Vector2) -> float: ...
    def norm(self) -> float: ...
    def squareNorm(self) -> float: ...
    def normalize(self) -> Vector2: ...
    def normalize_(self) -> None: ...

# Structure should be the same, except for the internal usage of f32 and f64
Vector2f = Vector2
Vector2d = Vector2

################################################################################
#                           Type hints for Vector3                             #
################################################################################

class Vector3:
    def __init__(
        self, *args: Union[float, ndarray], **kwargs: Union[float, ndarray]
    ): ...
    @property
    def x(self) -> float: ...
    @x.setter
    def x(self, value: float) -> None: ...
    @property
    def y(self) -> float: ...
    @y.setter
    def y(self, value: float) -> None: ...
    @property
    def z(self) -> float: ...
    @z.setter
    def z(self, value: float) -> None: ...
    def __add__(self, rhs: Vector3) -> Vector3: ...
    def __sub__(self, rhs: Vector3) -> Vector3: ...
    def __mul__(self, scale: float) -> Vector3: ...
    def __rmul__(self, scale: float) -> Vector3: ...
    def __eq__(self, other: Vector3) -> bool: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: float) -> None: ...
    def __neq__(self, other: Vector3) -> bool: ...
    def __neg__(self) -> Vector3: ...
    def cross(self, rhs: Vector3) -> Vector3: ...
    def dot(self, rhs: Vector3) -> float: ...
    def norm(self) -> float: ...
    def squareNorm(self) -> float: ...
    def normalize(self) -> Vector3: ...
    def normalize_(self) -> None: ...

# Structure should be the same, except for the internal usage of f32 and f64
Vector3f = Vector3
Vector3d = Vector3

################################################################################
#                           Type hints for Vector4                             #
################################################################################

class Vector4:
    def __init__(
        self, *args: Union[float, ndarray], **kwargs: Union[float, ndarray]
    ): ...
    @property
    def x(self) -> float: ...
    @x.setter
    def x(self, value: float) -> None: ...
    @property
    def y(self) -> float: ...
    @y.setter
    def y(self, value: float) -> None: ...
    @property
    def z(self) -> float: ...
    @z.setter
    def z(self, value: float) -> None: ...
    @property
    def w(self) -> float: ...
    @w.setter
    def w(self, value: float) -> None: ...
    def __add__(self, rhs: Vector4) -> Vector4: ...
    def __sub__(self, rhs: Vector4) -> Vector4: ...
    def __mul__(self, scale: float) -> Vector4: ...
    def __rmul__(self, scale: float) -> Vector4: ...
    def __eq__(self, other: Vector4) -> bool: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: float) -> None: ...
    def __neq__(self, other: Vector4) -> bool: ...
    def __neg__(self) -> Vector4: ...
    def dot(self, rhs: Vector4) -> float: ...
    def norm(self) -> float: ...
    def squareNorm(self) -> float: ...
    def normalize(self) -> Vector4: ...
    def normalize_(self) -> None: ...

# Structure should be the same, except for the internal usage of f32 and f64
Vector4f = Vector4
Vector4d = Vector4

################################################################################
#                          Type hints for Quaternion                           #
################################################################################

class Quaternion:
    def __init__(
        self, *args: Union[float, ndarray, List[float]], **kwargs: Union[float, ndarray]
    ): ...
    @property
    def w(self) -> float: ...
    @w.setter
    def w(self, value: float) -> None: ...
    @property
    def x(self) -> float: ...
    @x.setter
    def x(self, value: float) -> None: ...
    @property
    def y(self) -> float: ...
    @y.setter
    def y(self, value: float) -> None: ...
    @property
    def z(self) -> float: ...
    @z.setter
    def z(self, value: float) -> None: ...
    def __add__(self, rhs: Quaternion) -> Quaternion: ...
    def __sub__(self, rhs: Quaternion) -> Quaternion: ...
    def __mul__(self, rhs: Union[float, Quaternion]) -> Quaternion: ...
    def __rmul__(self, rhs: Union[float, Quaternion]) -> Quaternion: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: float) -> None: ...
    def __eq__(self, other: Quaternion) -> bool: ...
    def __neq__(self, other: Quaternion) -> bool: ...
    def length(self) -> float: ...
    def lengthSquare(self) -> float: ...
    def normalize(self) -> Quaternion: ...
    def normalize_(self) -> None: ...
    def conjugate(self) -> Quaternion: ...
    def inverse(self) -> Quaternion: ...
    def rotate(self, vec: Union[Vector3, ndarray]) -> Vector3: ...
    @staticmethod
    def RotationX(angle: float) -> Quaternion: ...
    @staticmethod
    def RotationY(angle: float) -> Quaternion: ...
    @staticmethod
    def RotationZ(angle: float) -> Quaternion: ...

# Structure should be the same, except for the internal usage of f32 and f64
Quaternionf = Quaternion
Quaterniond = Quaternion

################################################################################
#                            Type hints for Matrix3                            #
################################################################################

class Matrix3:
    def __init__(
        self,
        *args: Union[float, ndarray, Vector3],
        **kwargs: Union[float, ndarray, Vector3]
    ): ...
    @overload
    def __getitem__(self, index: int) -> Vector3: ...
    @overload
    def __getitem__(self, accessor: Tuple[int, int]) -> float: ...
    @overload
    def __setitem__(self, index: int, value: ndarray) -> None: ...
    @overload
    def __setitem__(self, accessor: Tuple[int, int], value: float) -> None: ...
    def __add__(self, rhs: Matrix3) -> Matrix3: ...
    def __sub__(self, rhs: Matrix3) -> Matrix3: ...
    @overload
    def __mul__(self, rhs: float) -> Matrix3: ...
    @overload
    def __mul__(self, rhs: Matrix3) -> Matrix3: ...
    @overload
    def __rmul__(self, rhs: float) -> Matrix3: ...
    @overload
    def __rmul__(self, rhs: Matrix3) -> Matrix3: ...
    def __eq__(self, other: Matrix3) -> bool: ...
    def __neq__(self, other: Matrix3) -> bool: ...
    @property
    def T(self) -> Matrix3: ...
    def flatten(self) -> ndarray: ...
    def transpose(self) -> Matrix3: ...
    def inverse(self) -> Matrix3: ...
    def trace(self) -> float: ...
    def determinant(self) -> float: ...
    @staticmethod
    def RotationX(angle: float) -> Matrix3: ...
    @staticmethod
    def RotationY(angle: float) -> Matrix3: ...
    @staticmethod
    def RotationZ(angle: float) -> Matrix3: ...
    @staticmethod
    @overload
    def Scale(scale_x: float, scale_y: float, scale_z: float) -> Matrix3: ...
    @staticmethod
    @overload
    def Scale(scales: ndarray) -> Matrix3: ...
    @staticmethod
    def Identity() -> Matrix3: ...
    @staticmethod
    def Zeros() -> Matrix3: ...

# Structure should be the same, except for the internal usage of f32 and f64
Matrix3f = Matrix3
Matrix3d = Matrix3
